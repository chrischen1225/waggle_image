#!/usr/bin/env python3

import copy
import getopt
import os
import os.path
import re
import subprocess
import sys
import time

config_directory = os.path.dirname(os.path.abspath(__file__))
sys.path.insert(0, os.path.realpath('{}/../lib/python/'.format(config_directory)))
import waggle.build as build

def main(argv):
  usage_message = ''.join(("Usage: add-build [OPTIONS]\n", \
                          "OPTIONS\n", \
                          "  --help                          ", \
                          "print help screen\n", \
                          "  -v |--version=<version>         ", \
                          "set the build version to <version>\n", \
                          "  -r |--revision=<revision>       ", \
                          "set the build revision to <revision>\n", \
                          "  -d |--deployment=<deployment_name>   ", \
                          "set the build deployment to <deployment>\n", \
                          "  -a |--architecture=<architecture>   ", \
                          "set the CPU architecture to <architecture>\n", \
                          "  -n |--nc-base=<base_id>         ", \
                          "set the Node Controller base ID to <base_id>\n", \
                          "  -e |--ep-base=<base_id>         ", \
                          "set the Edge Processor base ID to <base_id>\n", \
                          "  -t |--date=<base_id>            ", \
                          "set the date to <date>\n"))
  try:
    opts, args = getopt.getopt(
      argv, "v:r:d:a:n:e:t:",
      ["help", "version=", "revision=", "deployment=", "architecture=", "nc-base=", "ep-base=", "date="])
  except getopt.GetoptError as ge:
    print("\nError:", str(ge))
    print(usage_message + "\n")
    sys.exit(1)

  version = None
  revision = None
  deployment_name = None
  architecture_name = None
  nc_base_id = None
  ep_base_id = None
  date = None
  for opt, arg in opts:
    if opt == '--help':
      print("\n" + usage_message + "\n")
      sys.exit(0)
    elif opt in ('-v', '--version'):
      version = arg
    elif opt in ('-v', '--revision'):
      revision = int(arg)
    elif opt in ('-v', '--deployment'):
      deployment_name = arg
    elif opt in ('-a', '--architecture'):
      architecture_name = arg
    elif opt in ('-n', '--nc-base'):
      nc_base_id = int(arg)
    elif opt in ('-e', '--ep-base'):
      ep_base_id = int(arg)
    elif opt in ('-d', '--date'):
      date = arg
    else:
      print("\n" + usage_message + "\n")
      sys.exit(2)

  script_dir = os.path.dirname(os.path.abspath(__file__))

  build_config = build.Configuration(os.path.join(script_dir, 'build_config.json'))

  deployment = None
  if deployment_name != None:
    deployment = build_config.get_deployment(deployment_name)
    if deployment == None:
      print("Error: deployment '{}' does not exist".format(deployment_name))
      sys.exit(6)

  architecture = None
  if architecture_name != None:
    architecture = build_config.get_cpu_architecture(architecture_name)
    if architecture == None:
      print("Error: CPU architecture '{}' does not exist".format(architecture_name))
      sys.exit(6)
  if nc_base_id == None:
    nc_base_id = 1

  if ep_base_id == None:
    ep_base_id = 3

  if date == None:
    date = time.strftime('%Y-%m-%d')
  else:
    match = re.match('^[0-9]{4}-[0-1][0-9]-[0-3][0-9]$', date)
    if match == None:
      print("Error: invalid date (expected YYYY-MM-DD)")
      sys.exit(2)

  builds = build_config.get_builds()
  sorted_builds = sorted(builds,
    key=lambda bld: ''.join((bld['published_version'], str(bld['revision']))))

  # update version, revision, and base IDs
  new_build = None
  if version != None:
    print('CHECKPOINT 10')
    # version specified
    # either create a new version or create a new deployment for an existing version
    available_revisions = [bld for bld in builds if bld['published_version'] == version]
    if len(available_revisions) > 0:
      print('CHECKPOINT 20')
      # version exists
      # assuming a request of a new deployment or architecture for an existing version and revision
      if revision != None:
        print('CHECKPOINT 30')
        # revision specified
        # revision must exist to continue...
        existing_deployments = [bld for bld in available_revisions if bld['revision'] == revision]
        if len(existing_deployments) == 0:
          print("Error: revision '{}' is unavailable".format(revision))
          sys.exit(1)
        else:
          print('CHECKPOINT 33')
          # revision exists
          # default or specified deployment or architecture must *not* exist to continue...
          if deployment == None:
            deployment = build_config.get_deployment(eid=1)
          if architecture == None:
            architecture = build_config.get_cpu_architecture(eid=1)
          conflicts \
            = [bld for bld in existing_deployments if bld['deployment'] == deployment.eid and\
                                                      bld['cpu_architecture'] == architecture.eid]
          if len(conflicts) == 0:
            print('CHECKPOINT 36')
            # default or specified deployment or architecture do not exist
            # new deployment can be allocated
            new_build = dict(existing_deployments[0])
            new_build['deployment'] = deployment.eid
            new_build['cpu_architecture'] = architecture.eid
            new_build['nc_base'] = nc_base_id
            new_build['ep_base'] = ep_base_id
          else:
            print("Error: build with version '{}', revision '{}', deployment '{}', and "\
                  "architecture '{}' already exists".format(
                    version, revision, deployment['name'], architecture['name']))
            sys.exit(2)
      else:
        print('CHECKPOINT 40')
        # no revision specified
        # assuming a request for a new revision, deployment, or architecture

        # get one of the builds of the most recent revision
        sorted_revisions = sorted(available_revisions, key=lambda bld: str(bld['revision']))
        new_build = dict(sorted_revisions[-1])

        # get default deployment and architecture as needed
        if deployment == None:
          deployment = build_config.get_deployment(eid=1)
        if architecture == None:
          architecture = build_config.get_cpu_architecture(eid=1)
        print((nc_base_id, ep_base_id))

        # get the latest repo commit keys
        repos = ['waggle_image', 'core', 'nodecontroller', 'edge_processor', 'plugin_manager']
        key_prefixes = ['waggle_image', 'core', 'nc', 'ep', 'pm']
        commits = {}
        for repo,key_prefix in zip(repos, key_prefixes):
          cmd = "git ls-remote https://github.com/waggle-sensor/{}.git | head -1".format(repo)
          commits[key_prefix+'_commit'] \
            = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE).communicate()[0].decode()[:7]
        commit_keys = [key for key in new_build.keys() if 'commit' in key]

        # set new commit IDs if the latest commit IDs differ from those of the current revision
        increment_revision = False
        for key in commit_keys:
          if new_build[key] != commits[key]:
            increment_revision = True
            new_build[key] = commits[key]

        if increment_revision:
          print('CHECKPOINT 43')
          # commit IDs differ
          # increment the revision and set new commit IDs
          new_build['revision'] += 1
          new_build['deployment'] = deployment.eid
          new_build['cpu_architecture'] = architecture.eid
          new_build['nc_base'] = nc_base_id
          new_build['ep_base'] = ep_base_id
        else:
          print('CHECKPOINT 46')
          # commit IDs are the same
          # add another build of the same revision if either the default or specified deployment
          #   or architecture do not conflict
          revision = new_build['revision']

          # make sure there are no conflicts with both deployment and architecture
          conflicts \
            = [bld for bld in available_revisions \
               if bld['deployment'] == deployment.eid and bld['cpu_architecture'] == architecture.eid]
          if len(conflicts) > 0:
            print("Error: build with version '{}', revision '{}', deployment '{}', and "\
                  "architecture '{}' already exists".format(
                    version, revision, deployment['name'], architecture['name']))
            sys.exit(7)
          new_build['deployment'] = deployment.eid
          new_build['cpu_architecture'] = architecture.eid
          new_build['nc_base'] = nc_base_id
          new_build['ep_base'] = ep_base_id
    else:
      print('CHECKPOINT 50')
      # version does not exist
      # create a new version as specified
      if revision != None:
        print("Error: revision specified for new version")
        sys.exit(4)
      revision = 0
      if deployment == None:
        deployment = build_config.get_deployment(eid=1)
      if architecture == None:
        architecture = build_config.get_cpu_architecture(eid=1)
      if nc_base_id == None:
        nc_base_id = 1
      if ep_base_id == None:
        ep_base_id = 3
      # TODO: CHECK SORTED BUILDS!!!
      new_build = dict(sorted_builds[-1])
      new_build['published_version'] = version
      new_build['revision'] = revision
      new_build['deployment'] = deployment.eid
      new_build['cpu_architecture'] = architecture.eid
      new_build['nc_base'] = nc_base_id
      new_build['ep_base'] = ep_base_id
  else:
    print('CHECKPOINT 60')
    # no version specified
    # use the last known version and increment the revision
    new_build = dict(sorted_builds[-1])
    if revision != None:
      print("Error: revision specified without a version")
      sys.exit(5)
    new_build['revision'] += 1
  if new_build == None:
    print("Error: logic error (new_build == None)")
    sys.exit(99)

  if nc_base_id != None:
    new_build['nc_base'] = nc_base_id

  if ep_base_id != None:
    new_build['ep_base'] = ep_base_id

  # set the date
  new_build['date'] = date

  # add
  print(new_build)
  eid = build_config.add_build(build=new_build)
  print('eid: {}'.format(eid))
  new_build = build_config.get_build(eid=eid)
  # print(new_build)
  print('{} {} ({}) {} {}:'.format(
    new_build.eid, new_build['published_version'], new_build['revision'],
    deployment['name'], new_build['date']))
  print('  Bases:')
  base_ids = [new_build['nc_base'], new_build['ep_base']]
  for base_id in base_ids:
    base = build_config.get_base(eid=base_id)
    print('    {} {} ({}) {} - {}:'.format(
      base.eid, build_config.get_node_element(eid=base['node_element'])['name'],
      build_config.get_cpu_architecture(eid=base['cpu_architecture'])['name'], base['date'],
      base['uuid']))
  print('  Commit IDs:')
  repos = ['waggle_image  ', 'core          ', 'nodecontroller', 'edge_processor', 'plugin_manager']
  keys = ['waggle_image_commit', 'core_commit', 'nc_commit', 'ep_commit', 'pm_commit']
  for repo,key in zip(repos, keys):
    print('    {} {}'.format(repo, new_build[key]))


if __name__ == '__main__':
  main(sys.argv[1:])
