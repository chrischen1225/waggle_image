#!/usr/bin/env python3

import copy
import getopt
import os
import os.path
import subprocess
import sys
import time
import tinydb

import waggle.build as build

def main(argv):
  usage_message = ''.join(("Usage: add-build [OPTIONS]\n", \
                          "OPTIONS\n", \
                          "  --help                          ", \
                          "print help screen\n", \
                          "  -v |--version=<version>         ", \
                          "set the build version to <version>\n", \
                          "  -r |--revision=<revision>       ", \
                          "set the build revision to <revision>\n", \
                          "  -d |--deployment=<deployment>   ", \
                          "set the build deployment to <deployment>\n", \
                          "  -n |--nc-base=<base_id>         ", \
                          "set the Node Controller base ID to <base_id>\n", \
                          "  -e |--ep-base=<base_id>         ", \
                          "set the Edge Processor base ID to <base_id>\n", \
                          "  -t |--date=<base_id>            ", \
                          "set the date to <date>\n"))
  try:
    opts, args = getopt.getopt(
      argv, "v:r:d:n:e:t:",
      ["help", "version=", "revision=", "deployment=", "nc-base=", "ep-base=", "date="])
  except getopt.GetoptError as ge:
    print("\nError:", str(ge))
    print(usage_message + "\n")
    sys.exit(1)

  version = None
  revision = None
  deployment = None
  nc_base_id = None
  ep_base_id = None
  date = None
  for opt, arg in opts:
    if opt == '--help':
      print("\n" + usage_message + "\n")
      sys.exit(0)
    elif opt in ('-v', '--version'):
      version = arg
    elif opt in ('-v', '--revision'):
      revision = int(arg)
    elif opt in ('-v', '--deployment'):
      deployment = int(arg)
    elif opt in ('-n', '--nc-base'):
      nc_base_id = int(arg)
    elif opt in ('-e', '--ep-base'):
      ep_base_id = int(arg)
    elif opt in ('-d', '--date'):
      # TODO assert the date format YYYY-MM-DD
      date = arg
    else:
      print("\n" + usage_message + "\n")
      sys.exit(2)

  script_dir = os.path.dirname(os.path.abspath(__file__))

  build_config = build.Configuration()

  builds = build_config.get_builds()
  sorted_builds = sorted(builds,
    key=lambda bld: ''.join((bld['published_version'], str(bld['revision']))))

  # update version, revision, and base IDs
  new_build = None
  if version != None:
    # print('CHECKPOINT 10')
    # version specified
    # either create a new version or create a new deployment for an existing version
    available_revisions = [bld for bld in builds if bld['published_version'] == version]
    if len(available_revisions) > 0:
      # print('CHECKPOINT 20')
      # version exists
      # assuming a request of a new deployment for an existing version and revision
      if revision != None:
        # print('CHECKPOINT 30')
        # revision specified
        # revision must exist to continue...
        existing_deployments = [bld for bld in available_revisions if bld['revision'] == revision]
        if len(existing_deployments) == 0:
          print("Error: revision '{}' is unavailable".format(revision))
          sys.exit(1)
        else:
          # revision exists
          # default or specified deployment must *not* exist to continue...
          if deployment == None:
            deployment = 1
          deployment_conflicts = [bld for bld in existing_deployments if bld['deployment'] == deployment]
          if len(deployment_conflicts) == 0:
            # default or specified deployment does not exist
            # new deployment can be allocated
            new_build = dict(existing_deployments[0])
            new_build['deployment'] = deployment
          else:
            print("Error: deployment '{}' is already in use".format(deployment))
            sys.exit(2)
      else:
        # print('CHECKPOINT 40')
        # no revision specified
        # increment the last known revision for this deployment
        sorted_revisions = sorted(available_revisions, key=lambda bld: str(bld['revision']))
        new_build = dict(sorted_revisions[-1])
        revision = new_build['revision'] + 1

        if deployment == None:
          print("Error: version '{}' alread exists".format(version))
          sys.exit(7)
        new_build['revision'] = revision
        new_build['deployment'] = deployment
    else:
      # print('CHECKPOINT 50')
      # version does not exist
      # create a new version as specified
      if revision != None:
        print("Error: revision specified for new version")
        sys.exit(4)
      revision = 0
      if deployment == None:
        deployment = 1
      new_build = dict(sorted_builds[-1])
      new_build['published_version'] = version
      new_build['revision'] = revision
      new_build['deployment'] = deployment
  else:
    # print('CHECKPOINT 60')
    # no version specified
    # use the last known version and increment the revision
    new_build = dict(sorted_builds[-1])
    if revision != None:
      print("Error: revision specified without a version")
      sys.exit(5)
    new_build['revision'] += 1
  if new_build == None:
    print("Error: logic error (new_build == None)")
    sys.exit(99)

  if nc_base_id != None:
    new_build['nc_base_id'] = nc_base_id

  if ep_base_id != None:
    new_build['ep_base_id'] = ep_base_id

  # get the latest repo commit keys
  repos = ['waggle_image', 'core', 'nodecontroller', 'edge_processor', 'plugin_manager']
  key_prefixes = ['waggle_image', 'core', 'nc', 'ep', 'pm']
  commits = {}
  for repo,key_prefix in zip(repos, key_prefixes):
    cmd = "git ls-remote https://github.com/waggle-sensor/{}.git | head -1".format(repo)
    commits[key_prefix+'_commit'] \
      = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE).communicate()[0].decode()[:7]
  commit_keys = [key for key in new_build.keys() if 'commit' in key]
  for key in commit_keys:
    new_build[key] = commits[key]

  # set the date
  if date == None:
    date = time.strftime('%Y-%m-%d')
  new_build['date'] = date

  # add
  eid = build_config.add_build(build=new_build)
  # print('eid: {}'.format(eid))
  new_build = build_config.get_build(eid=eid)
  # print(new_build)
  deployment = build_config.get_deployment(eid=new_build['deployment'])
  if deployment == None:
    print("Error: deployment '{}' does not exist".format(new_build['deployment']))
    sys.exit(6)
  # print(deployment)
  print('{} {} ({}) {} {}:'.format(
    new_build.eid, new_build['published_version'], new_build['revision'],
    deployment['name'], new_build['date']))
  print('  Bases:')
  base_ids = [new_build['nc_base'], new_build['ep_base']]
  for base_id in base_ids:
    base = build_config.get_base(eid=base_id)
    print('    {} {} ({}) {} - {}:'.format(
      base.eid, build_config.get_node_element(eid=base['node_element'])['name'],
      build_config.get_cpu_architecture(eid=base['cpu_architecture'])['name'], base['date'],
      base['uuid']))
  print('  Commit IDs:')
  repos = ['waggle_image  ', 'core          ', 'nodecontroller', 'edge_processor', 'plugin_manager']
  keys = ['waggle_image_commit', 'core_commit', 'nc_commit', 'ep_commit', 'pm_commit']
  for repo,key in zip(repos, keys):
    print('    {} {}'.format(repo, new_build[key]))


if __name__ == '__main__':
  main(sys.argv[1:])
