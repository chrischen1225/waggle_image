#!/usr/bin/env python3

import copy
import getopt
import os
import os.path
import subprocess
import sys
import tinydb

import waggle.build as build

def main(argv):
  usage_message = ''.join(("Usage: add-build [OPTIONS]\n", \
                          "OPTIONS\n", \
                          "  --help                          ", \
                          "print help screen\n", \
                          "  -v |--version=<version>         ", \
                          "set the build version to <version>\n",
                          "                                  and revision to 0 (unless -r is used)\n", \
                          "  -r |--revision=<revision>       ", \
                          "set the build revision to <revision>\n",
                          "                                  if the revision exists (otherwise 0)\n", \
                          "  -n|--nc-base=<base_id>          ", \
                          "set the Node Controller base ID to <base_id>\n", \
                          "  -e |--ep-base=<base_id>         ", \
                          "set the Edge Processor base ID to <base_id>\n"))
  try:
    opts, args = getopt.getopt(
      argv, "v:r:d:n:e:", ["help", "version=", "revision=", "depolyment=", "nc-base=", "ep-base="])
  except getopt.GetoptError as ge:
    print("\nError:", str(ge))
    print(usage_message + "\n")
    sys.exit(1)

  version = None
  revision = None
  deployment = None
  nc_base_id = None
  ep_base_id = None
  for opt, arg in opts:
    if opt == '--help':
      print("\n" + usage_message + "\n")
      sys.exit(0)
    elif opt in ('-v', '--version'):
      version = arg
    elif opt in ('-v', '--revision'):
      revision = arg
    elif opt in ('-v', '--depolyment'):
      depolyment = arg
    elif opt in ('-n', '--nc-base'):
      nc_base_id = int(arg)
    elif opt in ('-e', '--ep-base'):
      ep_base_id = int(arg)
    else:
      print("\n" + usage_message + "\n")
      sys.exit(2)

  script_dir = os.path.dirname(os.path.abspath(__file__))

  build_config = build.Configuration()

  builds = build_config.get_builds()
  sorted_builds = sorted(builds,
    key=lambda bld: ''.join((bld['published_version'], str(bld['revision']))))

  # update version, revision, and base IDs
  new_build = None
  if version != None:
    # version specified
    # assuming a request of a new deployment for an existing version
    available_revisions = [bld for bld in builds if bld['published_version'] == version]
    if len(available_revisions) > 0:
      # version exists
      if revision != None:
        # assuming a request of a new deployment for an existing version and revision
        existing_deployments = [bld for bld in available_revisions if bld['revision'] == revision]
        if len(existing_deployments) == 0:
          print('Error: revision '{}' is unavailable'.format(revision))
          sys.exit(1)
        else:
          # revision exists
          # default or specified deployment must *not* exist to continue...
          if deployment == None:
            deployment = 1
          deployment_conflicts = [bld for bld in existing_deployments if bld['deployment'] == deployment]
          if len(deployment_conflicts) == 0:
            # new depoloyment can be allocated
            new_build = dict(existing_deployments[0])
            new_build['deployment'] = deployment
          else:
            print("Error: deployment '{}' is already in use".format(deployment))
            sys.exit(2)
      else:
        # no revision specified
        # increment the last known revision for this version
        sorted_revisions = sorted(available_revisions, key=lambda bld: str(bld['revision']))
        revision = sorted_revisions[-1]['revision'] + 1

        if deployment == None:
          deployment = 1
        new_build = dict(existing_deployments[0])
        new_build['revision'] = revision
        new_build['deployment'] = deployment
        else:
          print("Error: deployment '{}' is already in use".format(deployment))
          sys.exit(2)
    else:
      print("Error: version '{}' is unavailable".format(version))
      sys.exit(3)
  else:
    # no version specified
    # use the last known version and increment the revision
    new_build = dict(sorted_builds[-1])
    if revision != None:
      print("Error: revision specified without a version")
      sys.exit(4)
    new_build['revision'] += 1
  if new_build == None:
    print("Error: logic error (new_build == None)")
    sys.exit(99)

  if nc_base_id != None:
    new_build['nc_base_id'] = nc_base_id

  if ep_base_id != None:
    new_build['ep_base_id'] = ep_base_id

  # get the latest repo commit keys
  repos = ['waggle_image', 'core', 'nodecontroller', 'edge_processor', 'plugin_manager']
  key_prefixes = ['waggle_image', 'core', 'nc', 'ep', 'pm']
  commit_ids = {}
  for repo,key_prefix in zip(repos, key_prefixes):
    cmd = "git ls-remote https://github.com/waggle-sensor/{}.git | head -1".format(repo)
    commit_ids[key_prefix+'_commit_id'] \
      = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE).communicate()[0].decode()[:7]
  commit_keys = [key for key in new_build.keys() if 'commit_id' in key]
  for key in commit_keys:
    new_build[key] = commit_ids[key]

  # add 
  eid = build_config.add_build(build=new_build)

  new_build = build_config.get_build(eid=eid)
  print('{} {} ({}) {}:'.format(
    new_build.eid, new_build['published_version'], new_build['revision'], new_build['date']))
  print('  Bases:')
  base_ids = [new_build['nc_base_id'], new_build['ep_base_id']]
  for base_id in base_ids:
    base = build_config.get_base(eid=base_id)
    print('    {} {} ({}) {} - {}:'.format(
      base.eid, build_config.get_node_element(eid=base['node_element'])['name'],
      build_config.get_cpu_architecture(eid=base['cpu_architecture'])['name'], base['date'],
      base['uuid']))
  print('  Commit IDs:')
  repos = ['waggle_image  ', 'core          ', 'nodecontroller', 'edge_processor', 'plugin_manager']
  keys = ['waggle_image_commit_id', 'core_commit_id', 'nc_commit_id', 'ep_commit_id', 'pm_commit_id']
  for repo,key in zip(repos, keys):
    print('    {} {}'.format(repo, new_build[key]))


if __name__ == '__main__':
  main(sys.argv[1:])
